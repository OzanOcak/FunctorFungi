[{"content":"React Router is an essential library for building single-page applications (SPAs) in React. It provides a robust way to manage navigation, routes, and data fetching. In this guide, we’ll explore the createBrowserRouter API, its features like loaders and actions, and how it compares to using React Query for data management. To get started, install React Router if you haven’t already: npm install react-router-dom\nWhat is createBrowserRouter? createBrowserRouter is a part of React Router that simplifies route management in your React applications. It allows you to define routes declaratively and manage complex routing scenarios with ease.\nKey Features of createBrowserRouter 1- Declarative Routing: It allows you to define routes in a more declarative manner, making your code easier to read and maintain.\nimport { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; import Home from \u0026#34;./Home\u0026#34;; import About from \u0026#34;./About\u0026#34;; const router = createBrowserRouter([ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Home /\u0026gt;, }, { path: \u0026#34;/about\u0026#34;, element: \u0026lt;About /\u0026gt;, }, ]); function App() { return \u0026lt;RouterProvider router={router} /\u0026gt;; } 2- Nested Routes: It provides better support for nested routing, enabling you to create complex UIs with less boilerplate code.\nconst router = createBrowserRouter([ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Layout /\u0026gt;, children: [ { path: \u0026#34;dashboard\u0026#34;, element: \u0026lt;Dashboard /\u0026gt;, }, { path: \u0026#34;settings\u0026#34;, element: \u0026lt;Settings /\u0026gt;, }, ], }, ]); 3- Data Loading: The API integrates data loading and route handling, allowing you to fetch data directly as part of the routing process. This streamlines the data-fetching strategy.\nconst router = createBrowserRouter([ { path: \u0026#34;/user/:id\u0026#34;, element: \u0026lt;UserProfile /\u0026gt;, loader: async ({ params }) =\u0026gt; { const response = await fetch(`/api/users/${params.id}`); return response.json(); }, }, ]); 4- Error Handling: It simplifies error handling by allowing you to define error boundaries at the route level, making it easier to manage errors in your application.\nconst router = createBrowserRouter([ { path: \u0026#34;/dashboard\u0026#34;, element: \u0026lt;Dashboard /\u0026gt;, errorElement: \u0026lt;ErrorPage /\u0026gt;, // Custom error page component }, ]); 5- Asynchronous Routing: It supports asynchronous route loading, which helps improve performance by splitting code and loading only what is necessary for the current route.\nconst router = createBrowserRouter([ { path: \u0026#34;/lazy\u0026#34;, element: ( \u0026lt;React.Suspense fallback={\u0026lt;Loading /\u0026gt;}\u0026gt; \u0026lt;LazyComponent /\u0026gt; \u0026lt;/React.Suspense\u0026gt; ), }, ]); 6- Type Safety: If you\u0026rsquo;re using TypeScript, createBrowserRouter offers better type inference, reducing runtime errors and improving developer experience.\nimport { createBrowserRouter, RouteObject } from \u0026#34;react-router-dom\u0026#34;; const routes: RouteObject[] = [ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Home /\u0026gt;, }, { path: \u0026#34;/about\u0026#34;, element: \u0026lt;About /\u0026gt;, }, ]; const router = createBrowserRouter(routes); 7- Improved Flexibility: The router can handle various routing scenarios, including redirects and route transitions, with a more flexible API.\nconst router = createBrowserRouter([ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Home /\u0026gt;, }, { path: \u0026#34;/old-about\u0026#34;, redirect: \u0026#34;/about\u0026#34;, // Redirect from old to new route }, ]); Loaders Loaders are functions that fetch data before a route is rendered\nimport { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; const loadUserData = async ({ params }) =\u0026gt; { const response = await fetch(`/api/users/${params.id}`); if (!response.ok) { throw new Response(\u0026#34;User not found\u0026#34;, { status: 404 }); } return response.json(); }; const UserProfile = ({ data }) =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{data.name}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{data.email}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); const router = createBrowserRouter([ { path: \u0026#34;/user/:id\u0026#34;, element: \u0026lt;UserProfile /\u0026gt;, loader: loadUserData, }, ]); function App() { return \u0026lt;RouterProvider router={router} /\u0026gt;; } Actions Actions are functions that handle form submissions and other interactions.\nconst submitUserData = async ({ request }) =\u0026gt; { const formData = await request.formData(); const response = await fetch(\u0026#34;/api/users\u0026#34;, { method: \u0026#34;POST\u0026#34;, body: formData, }); if (!response.ok) { throw new Response(\u0026#34;Failed to create user\u0026#34;, { status: 400 }); } return response.json(); }; const CreateUser = () =\u0026gt; ( \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;/create-user\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;name\u0026#34; placeholder=\u0026#34;Name\u0026#34; required /\u0026gt; \u0026lt;input name=\u0026#34;email\u0026#34; placeholder=\u0026#34;Email\u0026#34; required /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Create User\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); const router = createBrowserRouter([ { path: \u0026#34;/create-user\u0026#34;, element: \u0026lt;CreateUser /\u0026gt;, action: submitUserData, }, ]); Comparison with React Query Using React Query React Query provides advanced features like caching, background data fetching, and global state management. Here’s a brief comparison:\nPros of React React Router: Integrated with Routing: Loaders are tied directly to route definitions, making it easy to fetch data when navigating to a specific route. Simplicity: For basic data fetching needs, using loaders keeps your code straightforward by centralizing data fetching logic alongside route definitions. Automatic Data Fetching: Data is automatically fetched when navigating to a route, which can simplify the component logic. Cons of React Router: Limited Features: Loaders lack advanced features like caching, background refetching, and automatic retries that are standard in dedicated data-fetching libraries. No Global State Management: Loaders do not provide a way to manage global state or share data across multiple components without re-fetching. Less Flexibility: They are designed for fetching data on route changes, which may not cover all use cases for data fetching in a more complex application. Conclusion createBrowserRouter is a powerful addition to React Router, simplifying routing and data fetching in your applications. With features like loaders and actions, it enhances your ability to manage complex UIs effectively. While React Query provides advanced data fetching capabilities, combining both can lead to a well-structured and efficient application.\nBy understanding the strengths of each tool, you can make informed decisions on how to structure your React applications for optimal performance and maintainability.\n","permalink":"http://localhost:1313/posts/react-router/","summary":"React Router is an essential library for building single-page applications (SPAs) in React. It provides a robust way to manage navigation, routes, and data fetching. In this guide, we’ll explore the createBrowserRouter API, its features like loaders and actions, and how it compares to using React Query for data management. To get started, install React Router if you haven’t already: npm install react-router-dom\nWhat is createBrowserRouter? createBrowserRouter is a part of React Router that simplifies route management in your React applications.","title":"Understanding React Router: A Comprehensive Guide to createBrowserRouter"},{"content":"In this article, we will walk through the steps to create a simple RESTful API using Node.js with Express, backed by a PostgreSQL database, all running in Docker containers. This setup allows for easy development and deployment, ensuring consistency across environments.\nStep 1: Set Up Your Project Create a project directory:\nmkdir express-postgres-api cd express-postgres-api Initialize a Node.js project:\nnpm init -y npm install express pg dotenv npm i -D nodemon cat package.json Step 2: Create the Express Application Create a new file named app.js: // app.js const express = require(\u0026#34;express\u0026#34;); const { Pool } = require(\u0026#34;pg\u0026#34;); const dotenv = require(\u0026#34;dotenv\u0026#34;); dotenv.config(); const app = express(); const port = process.env.PORT || 3000; // Middleware app.use(express.json()); // PostgreSQL connection const pool = new Pool({ user: process.env.DB_USER, host: process.env.DB_HOST, database: process.env.DB_NAME, password: process.env.DB_PASSWORD, port: process.env.DB_PORT, }); // Basic route app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;Hello World!\u0026#34;); }); // Get all items app.get(\u0026#34;/items\u0026#34;, async (req, res) =\u0026gt; { try { const result = await pool.query(\u0026#34;SELECT * FROM items\u0026#34;); res.json(result.rows); } catch (err) { console.error(err); res.status(500).send(\u0026#34;Server error\u0026#34;); } }); // Start the server app.listen(port, () =\u0026gt; { console.log(`Server running on http://localhost:${port}`); }); Create a .env file: In the project root, create a .env file to store your database configuration:\nDB_USER=pguser DB_HOST=db DB_NAME=pgdb DB_PASSWORD=pgpassword DB_PORT=5432 PORT=3000 Step 3: Create Docker Setup Next, we’ll configure Docker to run our application and database.\ndockerfile FROM node:14 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . CMD [\u0026#34;npm\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;dev\u0026#34;] docker-compose.yml This file will define the services for both the API and the PostgreSQL database:\n#version: \u0026#34;3.8\u0026#34; services: db: image: postgres:alpine environment: POSTGRES_USER: ${DB_USER} POSTGRES_PASSWORD: ${DB_PASSWORD} POSTGRES_DB: ${DB_NAME} ports: - \u0026#34;5432:5432\u0026#34; volumes: - pgdata:/var/lib/postgresql/data api: build: . ports: - \u0026#34;3000:3000\u0026#34; environment: - DB_USER=${DB_USER} - DB_HOST=${DB_HOST} - DB_NAME=${DB_NAME} - DB_PASSWORD=${DB_PASSWORD} - DB_PORT=${DB_PORT} depends_on: - db volumes: pgdata: Step 4: Create the Database Table Launch the Docker containers: docker compose up -d docker compose down # stopping the containers docker compose --build # re-building containers after any change is done Connect to the PostgreSQL container: Use the following command to access the PostgreSQL shell:\ndocker exec -it {db_container_name} psql -U {user_name} -d {db_name} docker exec -it express-postgres-api-db-1 psql -U pguser -d pgdb Create the items table and basic queries: Execute the following SQL commands:\nCREATE TABLE items ( id SERIAL PRIMARY KEY, name VARCHAR(100) NOT NULL ); insert into items (1, \u0026#39;tom\u0026#39;); select * from items; Step 5: Testing the API Now, let’s test our API to ensure everything is working as expected. We will use curl.\ndocker compose -d up curl http://localhost:3000 curl http://localhost:3000/items Conclusion In this tutorial, we successfully set up a simple RESTful API using Node.js, Express, and PostgreSQL, all running within Docker containers. This setup simplifies the development process and ensures that the application behaves consistently across different environments.\n","permalink":"http://localhost:1313/posts/node-express-api-docker/","summary":"In this article, we will walk through the steps to create a simple RESTful API using Node.js with Express, backed by a PostgreSQL database, all running in Docker containers. This setup allows for easy development and deployment, ensuring consistency across environments.\nStep 1: Set Up Your Project Create a project directory:\nmkdir express-postgres-api cd express-postgres-api Initialize a Node.js project:\nnpm init -y npm install express pg dotenv npm i -D nodemon cat package.","title":"Setting Up a Simple Node.js Express Api and PostgreSql database with Docker"},{"content":"Advanced Types TypeScript offers a robust type system that helps developers catch errors early and improve code quality. One of the powerful features of TypeScript is its advanced types, which include constructs like as const, tuples, generics, and built-in types. In this post, we’ll explore these concepts with code snippets for clarity.\nAs Const The as const assertion allows you to create immutable types. For example, while a normal variable can be mutable, using as const makes its properties read-only. This is particularly useful when creating enums or constant values.\nlet a: number = 4; // a is mutable const b = 5; // b is not mutable const c = 5 as const; // this is what actually happens behind the sceen const num = [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;] as const; // num.push(\u0026#39;4\u0026#39;) is still valid witout as const const object = { name: \u0026#34;\u0026#34;, age: 35, adress: { street: \u0026#34;\u0026#34; } } as const; // as const make every property as read only This can be effective for creating enums:\nconst LEVELS = [\u0026#34;begginer\u0026#34;, \u0026#34;intermadiate\u0026#34;, \u0026#34;advanced\u0026#34;] as const; // type LEVELS = [\u0026#39;begginer\u0026#39; | \u0026#39;intermadiate\u0026#39;| \u0026#39;advanced\u0026#39; } type Person = { skillLevel: (typeof LEVELS)[number] }; // can be assigned to variable LEVELS.forEach((level) =\u0026gt; console.log(level)); // this can be iterated unlice type Tuples Tuples are fixed-length arrays with specific types. They can be useful for representing structured data.\ntype Tuple = [string, boolean]; const person: Tuple = { name: \u0026#34;John\u0026#34;, age: 35 }; Object.entries(person).forEach(([key, value]) =\u0026gt; { console.log(key, value); }); // type Tuple = [string, boolean] ,note that useState returns tupple Generics Generics enable you to create reusable components that can work with any data type. The is an example of a generic type.\nconst input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#34;.input\u0026#34;); console.log(input); With functions, generics allow for flexibility:\nfunction getSecond\u0026lt;T\u0026gt;(array: T[]): T { array[1]; } const a = [1, 2, 3]; // returns 2 (T is number) const b = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; // returns b (T is string) A practical use case for generics is in API responses:\ntype APIResponse\u0026lt;TData\u0026gt; = { data: TData; error: boolean; }; const a: APIResponse\u0026lt;Array\u0026lt;number\u0026gt;\u0026gt; = { data: [1, 2, 3], isError: false }; Async Functions TypeScript can infer return types for async functions, making code cleaner and more readable.\nfunction wait(duration: number) { return new Promise\u0026lt;string\u0026gt;((res) =\u0026gt; { setTimeout(() =\u0026gt; res(\u0026#34;hi!\u0026#34;), duration); }); } wait(1000).then((value) =\u0026gt; { console.log(value.length); }); Build in Types TypeScript provides built-in utility types like Omit, Pick, Partial, and Required to manipulate types easily.\nOmit and Pick To create a new type based on an existing one, you can use Pick or Omit:\ntype NewTodo = Pick\u0026lt;Todo, \u0026quot;name\u0026quot; | \u0026quot;completed\u0026quot;\u0026gt; type NewTodo = Omit\u0026lt;Todo, \u0026quot;id\u0026quot;\u0026gt;\ntype Todo = { id:string; name:string; completed:boolean } type NewTodo = { name:string; completed:boolean; } function saveTodo(newTodo: NewTodo) { return {...newTodo, id:crypto.randomUUID() } Partial and Required To make properties optional or required:\ntype Todo = { title?: string; completed: boolean; address?: { street?: street; }; }; type RequiredPick\u0026lt;T, Key extends keyof T\u0026gt; = Required\u0026lt;Pick\u0026lt;T, Key\u0026gt;\u0026gt; \u0026amp; T; // we pick one of the keys from Todo type and make it required, lastly make it union with Todo but required overwrites so this code makes generic picked type as required. type FormTodo = RequiredPick\u0026lt;Todo, \u0026#34;title\u0026#34;\u0026gt;; // now title is require, it is not optional anymore type PartialPick\u0026lt;T, Key extends keyof T\u0026gt; = Partial\u0026lt;Pick\u0026lt;T, Key\u0026gt;\u0026gt; \u0026amp; Omit\u0026lt;T, Key\u0026gt;; // we pick one key and make it partial, lastly we union with all of the keys but it would overwrite required so we omit the specific key before unioning type FormTodo2 = PartialPick\u0026lt;Todo, \u0026#34;completed\u0026#34;\u0026gt;; // now completed is optional ReturnType and Parameters TypeScript allows you to extract the return type of a function or its parameters using ReturnType and Parameters.\nconst Func = () =\u0026gt; void type ReturnTypeOfFunc = ReturnType\u0026lt;typeof Func\u0026gt; // function checkLength(a: string, b: number) { return a.length() \u0026gt; b; } type ParamsOfCheckLen = Parameters\u0026lt;typeof CheckLength\u0026gt;; // [a:string, b:number] // a tupple Record The Record type is useful for creating objects with specific keys and values.\ntype PeopleGroupByName = Record\u0026lt;Person[\u0026#34;name\u0026#34;], Person[]\u0026gt;; Readonly The Readonly type creates immutable versions of existing types. This is basically same as const but readonly can be used for creating another type.\ntype FinalTodo = Readonly\u0026lt;Todo\u0026gt;; Type Narrowing Type narrowing allows for more precise type checking in your code. Basic type guards help differentiate types effectively.\nBasic Type Guards type Todo = { titles: string; property: \u0026#34;High\u0026#34; | \u0026#34;Normal\u0026#34; | \u0026#34;Low\u0026#34;; isComplete: boolean; description?: string; dueDate: Date | string; }; function extendTodo(todo: Todo) { if (typeof todo.dueDate === \u0026#34;string\u0026#34;) { // or todo.dueDate instanceof Date } else { console.log(todo.dueDate.getDate); } } checking undefined is possible with ?. Below code is equivalent to todo.description?.length \u0026gt; 5 if(todo.description !== undefined) { todo.description.length \u0026gt; 5 // length is not exist but it will not give error since we check if it is undefined but this is possible with todo.description?.length \u0026gt; 5 This ! also tell tsc that it is not possible be to be null but it overwrites typescript Discriminated Union Discriminated unions simplify handling different types:\ntype SuccessResponse = { status: \u0026#34;Success\u0026#34;; data: { id: string; name: string }; }; type ErrorResponse = { status: \u0026#34;Error\u0026#34;; errorMessage: string; }; type UserApiResponse = SuccessResponse | ErrorResponse; Function Overloads Function overloads allow you to define multiple ways to call a function based on different input types.\nfunction sum = (nums:number[]):number function sum = (a:number,b:number):number const t1 = sum([20,22]); const t2 = sum(20,22); Conclusion Understanding advanced types in TypeScript enhances code quality and maintainability. By leveraging features like as const, generics, utility types, and type narrowing, developers can write more robust and error-resistant applications. Embrace these tools to improve your TypeScript skills!\n","permalink":"http://localhost:1313/posts/typescript/","summary":"Advanced Types TypeScript offers a robust type system that helps developers catch errors early and improve code quality. One of the powerful features of TypeScript is its advanced types, which include constructs like as const, tuples, generics, and built-in types. In this post, we’ll explore these concepts with code snippets for clarity.\nAs Const The as const assertion allows you to create immutable types. For example, while a normal variable can be mutable, using as const makes its properties read-only.","title":"Understanding Advanced Types in TypeScript"},{"content":"I have build my first mobile app with React Native top of Expo framework. I have used Redux for state management and Tailwind for User Interface design. I have published it on Google Store. You can ger the app here\nBislingo ✓ Development: Developing your own vocabulary base on your interest help you master at language faster.\n✓ Entertaintment: Games can make it easier to learn educational contents and develop cognitive skills.\n✓ Interactivity: Quizzes help you identify what you know and what you don\u0026rsquo;t know\n✓ Entertaintment: Games can make it easier to learn educational contents and develop cognitive skills.\nNot just a regular dictionary app. You can build your own dictionary as you like. You can use it for any language you want. Moreover BisLingo has its own quiz builder that can produce random questions with your own entries and you can also practice your knowledge by playing hangman.\nI believe that BisLingo will revolutionize the way you learning language, and I can\u0026rsquo;t wait for you to try it out for yourself. Download it now and experience the convenience and ease of BisLingo. Thank you for your support, and please don\u0026rsquo;t hesitate to contact us with any questions or feedback. Sincerely, The developer of Bislingo\n","permalink":"http://localhost:1313/projects/building-mobile-app-with-expo-and-react-native/","summary":"I have build my first mobile app with React Native top of Expo framework. I have used Redux for state management and Tailwind for User Interface design. I have published it on Google Store. You can ger the app here\nBislingo ✓ Development: Developing your own vocabulary base on your interest help you master at language faster.\n✓ Entertaintment: Games can make it easier to learn educational contents and develop cognitive skills.","title":"Building Mobile App With Expo and React Native"},{"content":"I have built my personal website with Next framwork and React library, you can visit my website at oocak.com\nReact and Next.js are a great combination for building modern web applications. Here\u0026rsquo;s why they make a perfect couple and a tutorial on how to set up a Next.js app with a simple React user interface.\nReact and Next.js 1. Server-side Rendering (SSR): Next.js provides server-side rendering out of the box, which can improve the initial load time and search engine optimization (SEO) of your application, as opposed to a purely client-side React application.\n2. Static Site Generation (SSG): Next.js allows you to pre-render pages at build-time, creating highly performant \u0026ldquo;static\u0026rdquo; pages that can be served directly from a CDN.\n3. Routing and File-based Routing: Next.js has a file-based routing system, which makes it easy to set up and maintain the navigation structure of your application.\n4. Automatic Code Splitting: Next.js automatically splits your application\u0026rsquo;s code, reducing the amount of JavaScript that needs to be downloaded on each page load.\n5. Image Optimization: Next.js provides built-in image optimization, which can significantly improve the performance of your application.\n6. Seamless Integration with React: Next.js is built on top of React, so you can leverage all the power and flexibility of the React ecosystem. Tutorial: Setting up a Next.js App with a Simple React User Interface\nbrew install node npx create-next-app my-app This will create a new directory called my-app with the necessary files and folders for a Next.js application.\nDevelop the React User Interface: Next.js uses the pages directory to define your application\u0026rsquo;s routes. Open the pages directory and create a new file called index.js. In this file, you can build your React user interface:\nimport React from \u0026#39;react\u0026#39;; const HomePage = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Welcome to my Next.js App\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is a simple React user interface built with Next.js.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; export default HomePage; Run the Development Server: In your terminal, navigate to the my-app directory and run the following command to start the development server:\nnpm run dev This will start the Next.js development server and open your application in your default web browser.\nStatic Site Generation: Create pre-rendered pages at build-time using the getStaticProps or getStaticPaths functions.\nServer-side Rendering: Render pages on the server using the getServerSideProps function.\nAPI Routes: Create serverless API routes using the pages/api directory.\nStyling: Integrate CSS, Sass, or other styling solutions into your Next.js application.\nDeployment: Deploy your Next.js app to popular hosting platforms like Vercel, Netlify, or AWS. By combining the power of React and the features of Next.js, you can create high-performance, scalable web applications with a seamless user experience.\n","permalink":"http://localhost:1313/projects/building-personal-website-with-next-and-react/","summary":"I have built my personal website with Next framwork and React library, you can visit my website at oocak.com\nReact and Next.js are a great combination for building modern web applications. Here\u0026rsquo;s why they make a perfect couple and a tutorial on how to set up a Next.js app with a simple React user interface.\nReact and Next.js 1. Server-side Rendering (SSR): Next.js provides server-side rendering out of the box, which can improve the initial load time and search engine optimization (SEO) of your application, as opposed to a purely client-side React application.","title":"Building Personal Website With Next and React"},{"content":"Setting Up Hugo We need brew, go, git and hugo to build a Hugo website. I assume we already have bre and git are installed in our operating system.\nbrew install go go version brew install hugo hugo version hugo new site myspace code . Create Custom Layout Create a markdown file named as _index.md under content folder\n--- title: Home --- Hello World!!! and about.md with title: About then create default layout as baseof.html under /layouts/_default/ folder\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;{{.Page.Title}}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{ block \u0026#34;main\u0026#34; . }} {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; create two more html files under _default folder list.html for landing page and single.html for about page with below content\n{{ define \u0026#34;main\u0026#34;}} {{ .Content}} {{ end }} Stylesheet {{ $style := resources.Get \u0026#34;sass/main.scss\u0026#34; | resources.ToCSS | resources.Minify }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ $style.Permalink }}\u0026#34; /\u0026gt; then create main.scss under assets/sass/ folder\nbody { width: 400px; margin: 0 auto; font-family: sans-serif; } Partials Create a file name as nav.html under /layoutes/partials/\n\u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/about/\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; then add below line in the baseof.html\n{{ partial \u0026#34;nav.html\u0026#34; }} we can also create meta partial as meta.html\n\u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;{{ print .Page.Title }}\u0026lt;/title\u0026gt; {{ $style := resources.Get \u0026#34;sass/main.scss\u0026#34; | resources.ToCSS | resources.Minify }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ $style.Permalink }}\u0026#34; /\u0026gt; then add snippet in baseof.html\n{{ partial \u0026#34;meta.html\u0026#34; . }} That little . at the end is passing the context of the current page, which allows the partial to print out the current page’s title.\nTemplate \u0026lt;title\u0026gt;{{ .Params.title }} | {{ .Site.title }}\u0026lt;/title\u0026gt; \u0026lt;p\u0026gt;you can use double curly braces like this: {{ \u0026#34;Hello!\u0026#34; }}.\u0026lt;/p\u0026gt; {{ if isset .Params \u0026#34;title\u0026#34; }} \u0026lt;title\u0026gt;{{ .Params.title }}\u0026lt;/title\u0026gt; {{ else }} \u0026lt;title\u0026gt;{{ .Site.title }}\u0026lt;/title\u0026gt; {{ end }} {{ $favorite_food := \u0026#34;Gazelle\u0026#34; }} {{ $favorite_food }} {{ $best_friends := slice \u0026#34;pumbaa\u0026#34; \u0026#34;timon\u0026#34; \u0026#34;nala\u0026#34; \u0026#34;rafiki\u0026#34; }} \u0026lt;ul\u0026gt; {{ range $best_friends }} \u0026lt;li\u0026gt;{{ . }}\u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; to create conditiotonal templeting, enter params in config.toml or hugo.toml file\n[params] name = \u0026#39;Functor\u0026#39; then create a footer.html partial where footer will only seen if params is exist\n{{ with .Params.hide_footer }} \u0026lt;!-- No footer here! --\u0026gt; {{ else }} \u0026lt;footer\u0026gt;Website made by {{ .Site.Params.name }} in {{ now.Year }}\u0026lt;/footer\u0026gt; {{ end }} then add the partial in baseof.html\n{{ partial \u0026#34;footer.html\u0026#34; . }} we can hide footer in any html page(content) adding hide_footer just below title\nhide_footer: true Creating Blog cretate a file name as _index.md under /content/posts/\n--- title: Blog --- this markdown file will follow the rules of list.html unde /layouts/_default/ folder we can create our spesific layout if we also create list.html under /layout/posts folder\n{{ define \u0026#34;main\u0026#34;}} {{ .Content}} {{ end }} but we can also create single.html under /layout/posts/ folder so every post will follow the rules of single.html file\u0026rsquo;s rules\n{{ define \u0026#34;main\u0026#34;}} {{ .Content}} {{ end }} Using Available Layouts Above we can see basic hugo structure, alternatively we can use a theme to be able to see the site\nhugo new site myspace cd myspace git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml hugo server we can also use git clone instead of fit submodule add\nyou can refer from https://gohugo.io/getting-started/quick-start/ echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml or directly place below code to hugo.toml before running hugo server\ntheme: [\u0026#34;PaperMod\u0026#34;] delete draft = true or assign false to add content and publish it(files in public folder)\nhugo new content posts/my-first-post.md hugo server hugo when we created new post in terminal, the current time automatically created but if we like to create a file with default fron matter, we can add default fron matter in default.md under archtypes folder so next time when we create a file with hugo new content comment, all the fron matter will be added.\ntitle : \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; date : {{ .Date }} draft : true author: [\u0026#34;Ozan\u0026#34;] Hugo.toml Hugo.toml is a configuration file where we can define navigation, profile module and more.\nPublishing Website to Netlify After finishing the development of vebsite we can create public directory with hugo on terminal. The public directory will contain all the html, css, javascript and static files for the website, however we will upload our files to netlify so we can delete the public directory.\nhugo rm -rf ./public/ git init touch .gitmodules We need to initialize git file to push our filese to github then later we will connect the github repository to netlify. We also need to create a .gitmodules to define the theme for git.\n[submodule \u0026#34;themes/PaperMod\u0026#34;] path = themes/PaperMod url = \u0026#34;htps://github.com/adityatelange/hugo-PaperMod.git\u0026#34; Then we can push our project to github.\nFinally we can go to Netlify and click add new site, then import existing project and then log in with desired third party application, and then we can search our project in github. You can refer here.\nbase directory = build command = hugo publish directory = public HUGO_VERSION = hugo verion in terminal\n","permalink":"http://localhost:1313/posts/how-to-build-hugo-website/","summary":"Setting Up Hugo We need brew, go, git and hugo to build a Hugo website. I assume we already have bre and git are installed in our operating system.\nbrew install go go version brew install hugo hugo version hugo new site myspace code . Create Custom Layout Create a markdown file named as _index.md under content folder\n--- title: Home --- Hello World!!! and about.md with title: About then create default layout as baseof.","title":"How to Build Hugo Website"}]